var t={d:(e,n)=>{for(var o in n)t.o(n,o)&&!t.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:n[o]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)},e={};t.d(e,{mT:()=>v,sV:()=>E,zj:()=>y,n:()=>g,F5:()=>l,Ay:()=>T,h0:()=>h,J1:()=>c,Gv:()=>s,fX:()=>p,zp:()=>u,Zq:()=>f,QC:()=>o,Bb:()=>r,rE:()=>n});const n="1.1.0";function o(t){const e=/<!--.*?-->|<!\[CDATA\[(.*?)\]\]>|<\/([^>\s]+)\s*>|<([^>\s]+)([^>/]*)(\/?)>|([^<]+)/sy,n={t:"root",a:{},c:[]};let o=n;const r=[];for(;e.lastIndex<t.length;){const n=e.exec(t);if(null==n)throw new Error(`Unexpected end of source at position ${e.lastIndex}`);const[,s,i,c,a,l,f]=n;if(null!=s)o.c.push(s);else if(null!=i){const t=r.pop();if(!t||"string"==typeof t)throw new Error(`No opening tag for closing tag </${i}> at position ${e.lastIndex}`);if(o.t!==i)throw new Error(`Tag mismatch: opened <${o.t}> but closed </${i}> at position ${e.lastIndex}`);o=t}else if(null!=c&&null!=a){const t={t:c,a:{},c:[]},e=a.trimEnd(),n=/\s+([^\s=>]+)(="[^"]*"|='[^']*')?/sy;for(;n.lastIndex<e.length;){const o=n.exec(e);if(null==o)throw new Error(`Invalid attribute format at position ${n.lastIndex}`);const[,r,s]=o;null!=r&&(t.a[r]=null==s?r:s.slice(2,-1))}o.c.push(t),""===l&&(r.push(o),o=t)}else if(null!=f){const t=f.trim();t&&o.c.push(t)}}if(0!==r.length)throw new Error(`Unexpected end of source: unclosed tag <${o.t}>`);const s=n.c;if(null==s[0]||s.length>1)throw new Error("Create only one root element in your template");return s[0]}function r(t){return t.filter((t=>null!=t))}function s(t){return"object"==typeof t&&null!==t}function i(t,e){if(!e||!("onerror"in e)||"function"!=typeof e.onerror)throw t;e.onerror(t)}function c(t,e){if("function"!=typeof t)throw new Error;return(...n)=>{try{const o=t.apply(e,n);return s(o)&&"catch"in o&&"function"==typeof o.catch?o.catch((t=>{i(t,e)})):o}catch(t){i(t,e)}}}const a={};function l(t="",e){let n=a[t];if(!n){try{n=new Function("event",`return (${t});`)}catch{n=new Function("event",t)}a[t]=n}return c(n,e)}function f(t,e){if("string"==typeof e.class){let n=(t.getAttribute("class")??"").trim();const o=e.class.trim();""!==n&&""!==o&&(n+=" "),t.setAttribute("class",n+o)}if("string"==typeof e.style){let n=(t.getAttribute("style")??"").trim();const o=e.style.trim();""===n||""===o||n.endsWith(";")||(n+=";"),t.setAttribute("style",n+o)}}function u(t,e,n){for(const[o,r]of Object.entries(e))if("string"==typeof r&&!(n&&"id"===o||"for"===o||"class"===o||"style"===o))if(n&&o.startsWith("on")){const e=l(r,n);t.addEventListener(o.slice(2),e)}else t.setAttribute(o,r)}function p(t,e,n){u(t,e,n),f(t,e)}const d=new WeakMap;function m(t,e,n){if(!n)return;const o=["id","for"];for(const r of o){const o=t[r];if(null==o)continue;let s=d.get(n);s||(s={id:Object.create(null),for:Object.create(null)},d.set(n,s)),s[r][o]=e}}function h(t,e){const n=d.get(t);return n&&n.id[e]}function y(t,e,n){const o=w(t,e,n);if(!(o instanceof HTMLElement))throw new Error("The root node must be an HTMLElement.");return o}function w(t,e,n){if("string"==typeof t)return document.createTextNode(t);const o=r(t.c.map((t=>w(t,e,n)))),s=n?.[t.t];if(s){const n={...t.a};"id"in n&&delete n.id;const r=new s(n,o,e);return m(t.a,r,e),"element"in r&&r.element instanceof Node?r.element:void 0}const i=document.createElement(t.t);p(i,t.a,e);for(const t of o)i.appendChild(t);return m(t.a,i,e),i}function g(t,e,n){return y(o(t),e,n)}let b=0;function E(t,e){let n=e.id;n||(n="t-component-global-id-"+ ++b,e.id=n),t.htmlFor=n}class v{static nodeMap=new WeakMap;static uses;static template="<div></div>";static parsedTemplate={t:"div",a:{},c:[]};element;parentComponent;static from(t){const e=Object.hasOwn(this,"nodeMap")&&this.nodeMap.get(t);if(e)return e}constructor(t,e,n){const r=this.constructor;if(Object.hasOwn(r,"parsedTemplate")||(r.parsedTemplate=o(r.template)),this.element=y(r.parsedTemplate,this,r.uses),t&&p(this.element,t,n),e)for(const t of e)this.element.appendChild(t);n instanceof v&&(this.parentComponent=n);const s=d.get(this);if(s)for(const t in s.for){const e=s.for[t],n=s.id[t];e instanceof HTMLLabelElement&&n instanceof HTMLElement&&E(e,n)}Object.hasOwn(r,"nodeMap")||(r.nodeMap=new WeakMap),r.nodeMap.set(this.element,this)}id(t){return h(this,t)}onerror(t){if(!this.parentComponent)throw t;this.parentComponent.onerror(t)}}const T=v;var M=e.mT,O=e.sV,j=e.zj,x=e.n,A=e.F5,C=e.Ay,$=e.h0,I=e.J1,F=e.Gv,L=e.fX,W=e.zp,z=e.Zq,H=e.QC,k=e.Bb,B=e.rE;export{M as TComponent,O as bindLabel,j as buildElement,x as createElement,A as createEventFunction,C as default,$ as getElementById,I as handleFunctionError,F as isObject,L as mergeAttrs,W as mergeAttrsWithoutStyles,z as mergeStyles,H as parseTemplate,k as removeUndefined,B as version};