var t={d:(e,n)=>{for(var o in n)t.o(n,o)&&!t.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:n[o]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)},e={};t.d(e,{mT:()=>j,sV:()=>A,zj:()=>T,JU:()=>s,n:()=>v,F5:()=>m,Ay:()=>O,h0:()=>b,Tn:()=>r,Gv:()=>o,fX:()=>y,zp:()=>h,Zq:()=>d,QC:()=>a,st:()=>i,rE:()=>n,ek:()=>f});const n="1.1.0";function o(t){return"object"==typeof t&&null!==t}function r(t){return"function"==typeof t}function s(){return Object.create(null)}function i(t){return t.filter((t=>null!=t))}function c(...t){return new Function(...t)}function l(t,e){const n={t,a:{},c:[]},o=e.trimEnd(),r=/\s+([^\s=>]+)(="[^"]*"|='[^']*')?/suy;for(;r.lastIndex<o.length;){const t=r.exec(o);if(!t)throw new Error(`Invalid attribute format at position ${r.lastIndex}`);const[,e,s]=t;e&&(n.a[e]=null==s?e:s.slice(2,-1))}return n}function a(t){const e=/<!--.*?-->|<!\[CDATA\[(.*?)\]\]>|<\/([^>\s]+)\s*>|<([^>\s]+)([^>/]*)(\/?)>|([^<]+)/suy,n={t:"root",a:{},c:[]};let o=n;const r=[];for(;e.lastIndex<t.length;){const n=e.exec(t);if(!n)throw new Error(`Unexpected end of source at position ${e.lastIndex}`);const[,s,i,c,a,u,f]=n;if(null!=s)o.c.push(s);else if(null!=i){const t=r.pop();if(!t||"string"==typeof t)throw new Error(`No opening tag for closing tag </${i}> at position ${e.lastIndex}`);if(o.t!==i)throw new Error(`Tag mismatch: opened <${o.t}> but closed </${i}> at position ${e.lastIndex}`);o=t}else if(null!=c&&null!=a){const t=l(c,a);o.c.push(t),""===u&&(r.push(o),o=t)}else if(null!=f){const t=f.trim();t&&o.c.push(t)}}if(0!==r.length)throw new Error(`Unexpected end of source: unclosed tag <${o.t}>`);const s=n.c;if(null==s[0]||s.length>1)throw new Error("Create only one root element in your template");return s[0]}function u(t,e){if(!(e&&"onerror"in e&&r(e.onerror)))throw t;e.onerror(t)}function f(t,e){return(...n)=>{try{const s=t.apply(e,n);return o(s)&&"catch"in s&&r(s.catch)?s.catch((t=>{u(t,e)})):s}catch(t){u(t,e)}return null}}const p=s();function m(t,e){let n=p[t];if(!n){try{n=c("event",`return (${t});`)}catch{n=c("event",t)}p[t]=n}return f(n,e)}function d(t,e){if("string"==typeof e.class){let n=(t.getAttribute("class")??"").trim();const o=e.class.trim();""!==n&&""!==o&&(n+=" "),t.setAttribute("class",n+o)}if("string"==typeof e.style){let n=(t.getAttribute("style")??"").trim();const o=e.style.trim();""===n||""===o||n.endsWith(";")||(n+=";"),t.setAttribute("style",n+o)}}function h(t,e,n){for(const[o,r]of Object.entries(e))if((null==n||"id"!==o)&&"for"!==o&&"class"!==o&&"style"!==o)if(n&&o.startsWith("on")){const e=m(r,n);t[o]=e}else t.setAttribute(o,r)}function y(t,e,n){h(t,e,n),d(t,e)}const g=new WeakMap;function w(t,e,n){if(!n)return;const o=["id","for"];for(const r of o){const o=t[r];if(null!=o){let t=g.get(n);t||(t={id:s(),for:s()},g.set(n,t)),t[r][o]=e}}}function b(t,e){const n=g.get(t);return n&&n.id[e]}function E(t,e,n){if("string"==typeof t)return document.createTextNode(t);const o=i(t.c.map((t=>E(t,e,n)))),r=n?.[t.t];if(r){const n={...t.a};"id"in n&&delete n.id;const s=new r(n,o,e);return w(t.a,s,e),"element"in s&&s.element instanceof Node?s.element:null}const s=document.createElement(t.t);y(s,t.a,e);for(const t of o)s.appendChild(t);return w(t.a,s,e),s}function T(t,e,n){const o=E(t,e,n);if(!(o instanceof HTMLElement))throw new Error("The root node must be an HTMLElement.");return o}function v(t,e,n){return T(a(t),e,n)}let x=0;function A(t,e){let{id:n}=e;n||(x+=1,n=`t-component-global-id-${x}`,e.id=n),t.htmlFor=n}const C=new WeakMap;class j{static uses;static template="<div></div>";static parsedTemplate;element;parentComponent=null;static from(t){if(!o(t))return null;const e=C.get(t);return e instanceof this?e:null}constructor(t,e,n){const o=this.constructor;if(Object.prototype.hasOwnProperty.call(o,"parsedTemplate")&&o.parsedTemplate||(o.parsedTemplate=a(o.template)),this.element=T(o.parsedTemplate,this,o.uses),t&&y(this.element,t,n),e)for(const t of e)this.element.appendChild(t);n instanceof j&&(this.parentComponent=n);const r=g.get(this);if(r)for(const t in r.for)if(Object.prototype.hasOwnProperty.call(r.for,t)){const e=r.for[t],n=r.id[t];e instanceof HTMLLabelElement&&n instanceof HTMLElement&&A(e,n)}C.get(this.element)||C.set(this.element,this)}id(t,e){const n=b(this,t);if(e&&!(n instanceof e))throw new Error("Element is not an instance of the provided constructor");return n}onerror(t){if(!this.parentComponent)throw t;this.parentComponent.onerror(t)}}const O=j;var $=e.mT,I=e.sV,F=e.zj,L=e.JU,M=e.n,W=e.F5,H=e.Ay,k=e.h0,z=e.Tn,N=e.Gv,P=e.fX,U=e.zp,q=e.Zq,D=e.QC,G=e.st,J=e.rE,Q=e.ek;export{$ as TComponent,I as bindLabel,F as buildElement,L as createDictionary,M as createElement,W as createEventFunction,H as default,k as getElementById,z as isFunction,N as isObject,P as mergeAttrs,U as mergeAttrsWithoutStyles,q as mergeStyles,D as parseTemplate,G as removeNull,J as version,Q as wrapFunctionWithErrorHandling};