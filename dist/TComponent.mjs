var t={d:(e,n)=>{for(var o in n)t.o(n,o)&&!t.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:n[o]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)},e={};t.d(e,{mT:()=>C,sV:()=>x,zj:()=>E,JU:()=>s,n:()=>T,F5:()=>p,Ay:()=>j,h0:()=>w,Tn:()=>r,Gv:()=>o,fX:()=>h,zp:()=>d,Zq:()=>m,QC:()=>l,st:()=>i,rE:()=>n,ek:()=>u});const n="1.1.0";function o(t){return"object"==typeof t&&null!==t}function r(t){return"function"==typeof t}function s(){return Object.create(null)}function i(t){return t.filter((t=>null!=t))}function c(t,e){const n={t,a:{},c:[]},o=e.trimEnd(),r=/\s+([^\s=>]+)(="[^"]*"|='[^']*')?/suy;for(;r.lastIndex<o.length;){const t=r.exec(o);if(!t)throw new Error(`Invalid attribute format at position ${r.lastIndex}`);const[,e,s]=t;e&&(n.a[e]=null==s?e:s.slice(2,-1))}return n}function l(t){const e=/<!--.*?-->|<!\[CDATA\[(.*?)\]\]>|<\/([^>\s]+)\s*>|<([^>\s]+)([^>/]*)(\/?)>|([^<]+)/suy,n={t:"root",a:{},c:[]};let o=n;const r=[];for(;e.lastIndex<t.length;){const n=e.exec(t);if(!n)throw new Error(`Unexpected end of source at position ${e.lastIndex}`);const[,s,i,l,a,u,f]=n;if(null!=s)o.c.push(s);else if(null!=i){const t=r.pop();if(!t||"string"==typeof t)throw new Error(`No opening tag for closing tag </${i}> at position ${e.lastIndex}`);if(o.t!==i)throw new Error(`Tag mismatch: opened <${o.t}> but closed </${i}> at position ${e.lastIndex}`);o=t}else if(null!=l&&null!=a){const t=c(l,a);o.c.push(t),""===u&&(r.push(o),o=t)}else if(null!=f){const t=f.trim();t&&o.c.push(t)}}if(0!==r.length)throw new Error(`Unexpected end of source: unclosed tag <${o.t}>`);const s=n.c;if(null==s[0]||s.length>1)throw new Error("Create only one root element in your template");return s[0]}function a(t,e){if(!(e&&"onerror"in e&&r(e.onerror)))throw t;e.onerror(t)}function u(t,e){return(...n)=>{try{const s=t.apply(e,n);return o(s)&&"catch"in s&&r(s.catch)?s.catch((t=>{a(t,e)})):s}catch(t){a(t,e)}return null}}const f=s();function p(t,e){let n=f[t];if(!n){try{n=new Function("event",`return (${t});`)}catch{n=new Function("event",t)}f[t]=n}return u(n,e)}function m(t,e){if("string"==typeof e.class){let n=(t.getAttribute("class")??"").trim();const o=e.class.trim();""!==n&&""!==o&&(n+=" "),t.setAttribute("class",n+o)}if("string"==typeof e.style){let n=(t.getAttribute("style")??"").trim();const o=e.style.trim();""===n||""===o||n.endsWith(";")||(n+=";"),t.setAttribute("style",n+o)}}function d(t,e,n){for(const[o,r]of Object.entries(e))if(!(n&&"id"===o||"for"===o||"class"===o||"style"===o))if(n&&o.startsWith("on")){const e=p(r,n);t[o]=e}else t.setAttribute(o,r)}function h(t,e,n){d(t,e,n),m(t,e)}const y=new WeakMap;function g(t,e,n){if(!n)return;const o=["id","for"];for(const r of o){const o=t[r];if(null!=o){let t=y.get(n);t||(t={id:s(),for:s()},y.set(n,t)),t[r][o]=e}}}function w(t,e){const n=y.get(t);return n&&n.id[e]}function b(t,e,n){if("string"==typeof t)return document.createTextNode(t);const o=i(t.c.map((t=>b(t,e,n)))),r=n?.[t.t];if(r){const n={...t.a};"id"in n&&delete n.id;const s=new r(n,o,e);return g(t.a,s,e),"element"in s&&s.element instanceof Node?s.element:null}const s=document.createElement(t.t);h(s,t.a,e);for(const t of o)s.appendChild(t);return g(t.a,s,e),s}function E(t,e,n){const o=b(t,e,n);if(!(o instanceof HTMLElement))throw new Error("The root node must be an HTMLElement.");return o}function T(t,e,n){return E(l(t),e,n)}let v=0;function x(t,e){let{id:n}=e;n||(v+=1,n=`t-component-global-id-${v}`,e.id=n),t.htmlFor=n}const A=new WeakMap;class C{static uses;static template="<div></div>";static parsedTemplate;element;parentComponent=null;static from(t){if(!o(t))return null;const e=A.get(t);return e instanceof this?e:null}constructor(t,e,n){const o=this.constructor;if(Object.prototype.hasOwnProperty.call(o,"parsedTemplate")&&o.parsedTemplate||(o.parsedTemplate=l(o.template)),this.element=E(o.parsedTemplate,this,o.uses),t&&h(this.element,t,n),e)for(const t of e)this.element.appendChild(t);n instanceof C&&(this.parentComponent=n);const r=y.get(this);if(r)for(const t in r.for)if(Object.prototype.hasOwnProperty.call(r.for,t)){const e=r.for[t],n=r.id[t];e instanceof HTMLLabelElement&&n instanceof HTMLElement&&x(e,n)}A.get(this.element)||A.set(this.element,this)}id(t,e){const n=w(this,t);if(e&&!(n instanceof e))throw new Error("Element is not an instance of the provided constructor");return n}onerror(t){if(!this.parentComponent)throw t;this.parentComponent.onerror(t)}}const j=C;var O=e.mT,$=e.sV,F=e.zj,I=e.JU,L=e.n,M=e.F5,W=e.Ay,H=e.h0,k=e.Tn,z=e.Gv,N=e.fX,P=e.zp,U=e.Zq,q=e.QC,D=e.st,G=e.rE,J=e.ek;export{O as TComponent,$ as bindLabel,F as buildElement,I as createDictionary,L as createElement,M as createEventFunction,W as default,H as getElementById,k as isFunction,z as isObject,N as mergeAttrs,P as mergeAttrsWithoutStyles,U as mergeStyles,q as parseTemplate,D as removeNull,G as version,J as wrapFunctionWithErrorHandling};