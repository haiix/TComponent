{"version":3,"file":"TComponent.mjs","mappings":"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","sources":["webpack://@haiix/tcomponent/webpack/bootstrap","webpack://@haiix/tcomponent/webpack/runtime/define property getters","webpack://@haiix/tcomponent/webpack/runtime/hasOwnProperty shorthand","webpack://@haiix/tcomponent/./src/TComponent.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","/*\n * TComponent.ts\n *\n * Copyright (c) 2024 haiix\n *\n * This software is released under the MIT license.\n * See: https://opensource.org/licenses/MIT\n */\n\n/**\n * The version of TComponent.\n * @public\n */\nexport const version = '1.1.2';\n\n/**\n * The regex flags for the regex used in the parseTemplate function.\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type ConstructorOf<T> = new (...args: any[]) => T;\n\n/**\n * Generic type representing a function.\n * @public\n */\nexport type AnyFunction = (...args: unknown[]) => unknown;\n\n/**\n * TComponent attributes.\n * @public\n */\nexport type TAttributes = Record<string, string>;\n\n/**\n * TNode type intermediate.\n * @public\n */\nexport interface IntermediateTNode {\n  t: string;\n  a: TAttributes;\n  c: TNode[];\n}\n\n/**\n * TNode type.\n * @public\n */\nexport type TNode = IntermediateTNode | string;\n\n/**\n * Checks if the value is an object.\n * @param value - The value to check.\n * @returns True if the value is an object, otherwise false.\n * @public\n */\nexport function isObject(value: unknown): value is object {\n  return typeof value === 'object' && value !== null;\n}\n\n/**\n * Checks if the target is a function.\n * @param target - The target to check.\n * @returns True if the target is a function, otherwise false.\n * @public\n */\nexport function isFunction(target: unknown): target is AnyFunction {\n  return typeof target === 'function';\n}\n\n/**\n * Creates a dictionary object.\n * @returns A new dictionary object.\n * @public\n */\nexport function createDictionary<T>(): Record<string, T> {\n  return Object.create(null) as Record<string, T>;\n}\n\n/**\n * Removes null and undefined values from an array.\n * @param arr - The array to filter.\n * @returns A new array without null and undefined values.\n * @public\n */\nexport function removeNull<T>(arr: (T | null | undefined)[]): T[] {\n  return arr.filter((value): value is T => value != null);\n}\n\n/**\n * Creates a new function from the given arguments.\n * @param args - The arguments for the function.\n * @returns The created function.\n */\nfunction createFunction(...args: string[]): AnyFunction {\n  // eslint-disable-next-line no-new-func, @typescript-eslint/no-implied-eval\n  return new Function(...args) as AnyFunction;\n}\n\n/**\n * Parses the arguments of a tag.\n * @param start - The start tag.\n * @param attrs - The attributes string.\n * @returns The parsed IntermediateTNode.\n */\nfunction parseArguments(start: string, attrs: string): IntermediateTNode {\n  const newNode: IntermediateTNode = { t: start, a: {}, c: [] };\n  const attrRe = /\\s+([^\\s=>]+)(?:=\"([^\"]*)\"|='([^']*)'|(=))?/suy;\n  let match;\n  while ((match = attrRe.exec(attrs))) {\n    const [, key, dqValue, sqValue, invalid] = match;\n    if (invalid) {\n      throw new Error(`Invalid attribute value at position ${match.index + 1}`);\n    }\n    if (key) {\n      newNode.a[key] = dqValue ?? sqValue ?? key;\n    }\n  }\n  return newNode;\n}\n\n/**\n * Validates the end tag.\n * @param current - The current node.\n * @param node - The node to validate.\n * @param end - The end tag.\n * @param lastIndex - The last index of the regex.\n * @returns The validated node.\n */\nfunction validateEndTag(\n  current: IntermediateTNode,\n  node: TNode | undefined,\n  end: string,\n  lastIndex: number,\n): IntermediateTNode {\n  if (!node || typeof node === 'string') {\n    throw new Error(\n      `No opening tag for closing tag </${end}> at position ${lastIndex}`,\n    );\n  }\n  if (current.t !== end) {\n    throw new Error(\n      `Tag mismatch: opened <${current.t}> but closed </${end}> at position ${lastIndex}`,\n    );\n  }\n  return node;\n}\n\n/**\n * Processes a part of the template.\n * @param src - The source string.\n * @param re - The regex to use.\n * @param _current - The current node.\n * @param stack - The stack of nodes.\n * @returns The processed node.\n */\nfunction parseTemplateProcPart(\n  src: string,\n  re: RegExp,\n  _current: IntermediateTNode,\n  stack: TNode[],\n): IntermediateTNode {\n  let current = _current;\n  const result = re.exec(src);\n  if (!result) {\n    throw new Error(`Unexpected end of source at position ${re.lastIndex}`);\n  }\n  const [, cdata, end, start, attrs, oclose, text] = result;\n  if (cdata != null) {\n    current.c.push(cdata);\n  } else if (end != null) {\n    current = validateEndTag(current, stack.pop(), end, re.lastIndex);\n  } else if (start != null && attrs != null) {\n    const newNode = parseArguments(start, attrs);\n    current.c.push(newNode);\n    if (oclose === '') {\n      stack.push(current);\n      current = newNode;\n    }\n  } else if (text != null) {\n    const trimmedText = text.trim();\n    if (trimmedText) {\n      current.c.push(trimmedText);\n    }\n  }\n  return current;\n}\n\n/**\n * Processes the template.\n * @param src - The source string.\n * @param root - The root node.\n * @public\n */\nfunction parseTemplateProc(src: string, root: IntermediateTNode): void {\n  const re =\n    /<!--.*?-->|<!\\[CDATA\\[(.*?)\\]\\]>|<\\/([^>\\s]+)\\s*>|<([^>\\s]+)([^>/]*)(\\/?)>|([^<]+)/suy;\n  let current = root;\n  const stack: TNode[] = [];\n  while (re.lastIndex < src.length) {\n    current = parseTemplateProcPart(src, re, current, stack);\n  }\n  if (stack.length) {\n    throw new Error(`Unexpected end of source: unclosed tag <${current.t}>`);\n  }\n}\n\n/**\n * Parses the template string.\n * @param src - The template string.\n * @returns The parsed TNode.\n * @public\n */\nexport function parseTemplate(src: string): TNode {\n  const root: IntermediateTNode = { t: 'root', a: {}, c: [] };\n  parseTemplateProc(src, root);\n  const firstNode = root.c.shift();\n  if (!firstNode || root.c.length) {\n    throw new Error('Create only one root element in your template');\n  }\n  return firstNode;\n}\n\n/**\n * Handles errors by calling the onerror method if available.\n * @param error - The error to handle.\n * @param thisObj - The object that may have an onerror method.\n */\nfunction handleError(error: unknown, thisObj?: object): void {\n  if (thisObj && 'onerror' in thisObj && isFunction(thisObj.onerror)) {\n    thisObj.onerror(error);\n  } else {\n    throw error;\n  }\n}\n\n/**\n * Wraps a function with error handling.\n * @param fn - The function to wrap.\n * @param thisObj - The object that may have an onerror method.\n * @returns The wrapped function.\n * @public\n */\nexport function wrapFunctionWithErrorHandling(\n  fn: AnyFunction,\n  thisObj?: object,\n): AnyFunction {\n  return (...args: unknown[]) => {\n    try {\n      const result = fn.apply(thisObj, args);\n      if (isObject(result) && 'catch' in result && isFunction(result.catch)) {\n        return result.catch((error: unknown) => {\n          handleError(error, thisObj);\n        });\n      }\n      return result;\n    } catch (error) {\n      handleError(error, thisObj);\n    }\n    return null;\n  };\n}\n\nconst eventFuncCache = createDictionary<AnyFunction>();\n\n/**\n * Creates an event function from the given code.\n * @param code - The code for the function.\n * @param thisObj - The object that may have an onerror method.\n * @returns The created event function.\n * @public\n */\nexport function createEventFunction(\n  code: string,\n  thisObj?: object,\n): AnyFunction {\n  let fc = eventFuncCache[code];\n  if (!fc) {\n    try {\n      fc = createFunction('event', `return (${code});`);\n    } catch {\n      fc = createFunction('event', code);\n    }\n    eventFuncCache[code] = fc;\n  }\n  return wrapFunctionWithErrorHandling(fc, thisObj);\n}\n\n/**\n * Merge classes and styles into components.\n * @param element - Element whose attributes are to be merged.\n * @param attrs - Attribute values passed in the constructor.\n * @public\n */\nexport function mergeStyles(element: HTMLElement, attrs: TAttributes): void {\n  if (typeof attrs.class === 'string') {\n    let pClass = (element.getAttribute('class') ?? '').trim();\n    const cClass = attrs.class.trim();\n    if (pClass !== '' && cClass !== '') {\n      pClass += ' ';\n    }\n    element.setAttribute('class', pClass + cClass);\n  }\n  if (typeof attrs.style === 'string') {\n    let pStyle = (element.getAttribute('style') ?? '').trim();\n    const cStyle = attrs.style.trim();\n    if (pStyle !== '' && cStyle !== '' && !pStyle.endsWith(';')) {\n      pStyle += ';';\n    }\n    element.setAttribute('style', pStyle + cStyle);\n  }\n}\n\n/**\n * Merges attributes into an element without merging styles.\n * @param element - The element to merge attributes into.\n * @param attrs - The attributes to merge.\n * @param thisObj - The object that may have event handlers.\n * @public\n */\nexport function mergeAttrsWithoutStyles(\n  element: HTMLElement,\n  attrs: TAttributes,\n  thisObj?: object,\n): void {\n  for (const [name, value] of Object.entries(attrs)) {\n    if (\n      !(\n        (thisObj != null && name === 'id') ||\n        name === 'for' ||\n        name === 'class' ||\n        name === 'style'\n      )\n    ) {\n      if (thisObj && name.startsWith('on')) {\n        const fn = createEventFunction(value, thisObj);\n        (element as unknown as Record<string, unknown>)[name] = fn;\n      } else {\n        element.setAttribute(name, value);\n      }\n    }\n  }\n}\n\n/**\n * Merge attributes into components.\n * @param element - Element whose attributes are to be merged.\n * @param attrs - Attribute values passed in the constructor.\n * @param thisObj - TComponent instance.\n * @public\n */\nexport function mergeAttrs(\n  element: HTMLElement,\n  attrs: TAttributes,\n  thisObj?: object,\n): void {\n  mergeAttrsWithoutStyles(element, attrs, thisObj);\n  mergeStyles(element, attrs);\n}\n\nconst idMap = new WeakMap<\n  object,\n  { id: Record<string, object>; for: Record<string, object> }\n>();\n\n/**\n * Registers an ID for the target object.\n * @param attrs - The attributes containing the ID.\n * @param target - The target object.\n * @param thisObj - The object to register the ID with.\n */\nfunction registerId(\n  attrs: TAttributes,\n  target: object,\n  thisObj?: object,\n): void {\n  if (!thisObj) {\n    return;\n  }\n  const types = ['id', 'for'] as const;\n  for (const type of types) {\n    const id = attrs[type];\n    if (id != null) {\n      let idm = idMap.get(thisObj);\n      if (!idm) {\n        idm = {\n          id: createDictionary<object>(),\n          for: createDictionary<object>(),\n        };\n        idMap.set(thisObj, idm);\n      }\n      idm[type][id] = target;\n    }\n  }\n}\n\n/**\n * Gets an element by its ID.\n * @param thisObj - The object containing the ID map.\n * @param name - The ID of the element.\n * @returns The element with the given ID.\n * @public\n */\nexport function getElementById(thisObj: object, name: string): unknown {\n  const idm = idMap.get(thisObj);\n  return idm && idm.id[name];\n}\n\n/**\n * A dictionary of components to use.\n * @public\n */\nexport type TComponentUses = Record<string, ConstructorOf<object>>;\n\n/**\n * Recursively builds an element from a TNode.\n * @param tNode - The TNode to build from.\n * @param thisObj - The object to associate with the element.\n * @param uses - The components to use.\n * @returns The built node.\n */\nfunction buildElementRecur(\n  tNode: TNode,\n  thisObj?: object,\n  uses?: TComponentUses,\n): Node | null {\n  // Text node\n  if (typeof tNode === 'string') {\n    return document.createTextNode(tNode);\n  }\n  const nodes = removeNull(\n    tNode.c.map((childNode) => buildElementRecur(childNode, thisObj, uses)),\n  );\n  // Sub component\n  const SubComponent = uses?.[tNode.t];\n  if (SubComponent) {\n    const attrs = { ...tNode.a };\n    if ('id' in attrs) {\n      delete attrs.id;\n    }\n    const obj = new SubComponent(attrs, nodes, thisObj);\n    registerId(tNode.a, obj, thisObj);\n    if ('element' in obj && obj.element instanceof Node) {\n      return obj.element;\n    }\n    return null;\n  }\n  // Element\n  const element = document.createElement(tNode.t);\n  mergeAttrs(element, tNode.a, thisObj);\n  for (const node of nodes) {\n    element.appendChild(node);\n  }\n  registerId(tNode.a, element, thisObj);\n  return element;\n}\n\n/**\n * Builds an element from a TNode.\n * @param tNode - The TNode to build from.\n * @param thisObj - The object to associate with the element.\n * @param uses - The components to use.\n * @returns The built HTMLElement.\n * @public\n */\nexport function buildElement(\n  tNode: TNode,\n  thisObj?: object,\n  uses?: TComponentUses,\n): HTMLElement {\n  const node = buildElementRecur(tNode, thisObj, uses);\n  if (!(node instanceof HTMLElement)) {\n    throw new Error('The root node must be an HTMLElement.');\n  }\n  return node;\n}\n\n/**\n * Creates an element from an HTML string.\n * @param html - The HTML string.\n * @param thisObj - The object to associate with the element.\n * @param uses - The components to use.\n * @returns The created HTMLElement.\n * @public\n */\nexport function createElement(\n  html: string,\n  thisObj?: object,\n  uses?: TComponentUses,\n): HTMLElement {\n  return buildElement(parseTemplate(html), thisObj, uses);\n}\n\nlet globalIdCounter = 0;\n\n/**\n * Binds a label element to a target element.\n * @param labelElem - The label element.\n * @param targetElem - The target element.\n * @public\n */\nexport function bindLabel(\n  labelElem: HTMLLabelElement,\n  targetElem: HTMLElement,\n): void {\n  let { id } = targetElem;\n  if (!id) {\n    globalIdCounter += 1;\n    id = `t-component-global-id-${globalIdCounter}`;\n    targetElem.id = id;\n  }\n  labelElem.htmlFor = id;\n}\n\nconst nodeMap = new WeakMap<object, TComponent>();\n\n/**\n * The base class for TComponent.\n * @public\n */\nexport class TComponent {\n  static uses?: TComponentUses;\n  static template = '<div></div>';\n  static parsedTemplate?: TNode;\n  readonly element: HTMLElement;\n  parentComponent: TComponent | null = null;\n\n  /**\n   * Retrieves a TComponent instance from an element.\n   * @param this - The TComponent constructor.\n   * @param element - The element to retrieve the instance from.\n   * @returns The TComponent instance or null.\n   */\n  static from<T extends typeof TComponent>(\n    this: T,\n    element: unknown,\n  ): InstanceType<T> | null {\n    if (!isObject(element)) return null;\n    const component = nodeMap.get(element);\n    if (!(component instanceof this)) return null;\n    return component as InstanceType<T>;\n  }\n\n  /**\n   * Creates an instance of TComponent.\n   * @param attrs - The attributes for the component.\n   * @param nodes - The child nodes for the component.\n   * @param parent - The parent object.\n   */\n  constructor(attrs?: TAttributes, nodes?: Node[], parent?: object) {\n    const SubComponent = this.constructor as typeof TComponent;\n    if (\n      !Object.hasOwn(SubComponent, 'parsedTemplate') ||\n      !SubComponent.parsedTemplate\n    ) {\n      SubComponent.parsedTemplate = parseTemplate(SubComponent.template);\n    }\n    this.element = buildElement(\n      SubComponent.parsedTemplate,\n      this,\n      SubComponent.uses,\n    );\n\n    if (attrs) {\n      mergeAttrs(this.element, attrs, parent);\n    }\n    if (nodes) {\n      for (const node of nodes) {\n        this.element.appendChild(node);\n      }\n    }\n    if (parent instanceof TComponent) {\n      this.parentComponent = parent;\n    }\n\n    const idm = idMap.get(this);\n    if (idm) {\n      for (const key of Object.keys(idm.for)) {\n        const labelElem = idm.for[key];\n        const targetElem = idm.id[key];\n        if (\n          labelElem instanceof HTMLLabelElement &&\n          targetElem instanceof HTMLElement\n        ) {\n          bindLabel(labelElem, targetElem);\n        }\n      }\n    }\n\n    if (!nodeMap.get(this.element)) nodeMap.set(this.element, this);\n  }\n\n  /**\n   * Retrieves an element by its ID.\n   * @param id - The ID of the element.\n   * @returns The element with the given ID.\n   */\n  protected id(id: string): unknown;\n\n  /**\n   * Retrieves an element by its ID and checks its constructor.\n   * @param id - The ID of the element.\n   * @param constructor - The constructor to check.\n   * @returns The element with the given ID.\n   */\n  protected id<T>(id: string, constructor: ConstructorOf<T>): T;\n\n  protected id<T>(id: string, constructor?: ConstructorOf<T>): unknown {\n    const element = getElementById(this, id);\n    if (constructor && !(element instanceof constructor)) {\n      throw new Error('Element is not an instance of the provided constructor');\n    }\n    return element;\n  }\n\n  /**\n   * Handles errors by propagating them to the parent component or throwing them.\n   * @param error - The error to handle.\n   */\n  onerror(error: unknown): void {\n    if (this.parentComponent) {\n      this.parentComponent.onerror(error);\n    } else {\n      throw error;\n    }\n  }\n}\n\nexport default TComponent;\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","version","isObject","value","isFunction","target","createDictionary","create","removeNull","arr","filter","createFunction","args","Function","parseTemplateProcPart","src","re","_current","stack","current","result","exec","Error","lastIndex","cdata","end","start","attrs","oclose","text","c","push","node","t","validateEndTag","pop","newNode","a","attrRe","match","dqValue","sqValue","invalid","index","parseArguments","trimmedText","trim","parseTemplate","root","length","parseTemplateProc","firstNode","shift","handleError","error","thisObj","onerror","wrapFunctionWithErrorHandling","fn","apply","catch","eventFuncCache","createEventFunction","code","fc","mergeStyles","element","class","pClass","getAttribute","cClass","setAttribute","style","pStyle","cStyle","endsWith","mergeAttrsWithoutStyles","name","entries","startsWith","mergeAttrs","idMap","WeakMap","registerId","types","type","id","idm","for","set","getElementById","buildElementRecur","tNode","uses","document","createTextNode","nodes","map","childNode","SubComponent","Node","createElement","appendChild","buildElement","HTMLElement","html","globalIdCounter","bindLabel","labelElem","targetElem","htmlFor","nodeMap","TComponent","static","parentComponent","from","component","this","constructor","parent","hasOwn","parsedTemplate","template","keys","HTMLLabelElement"],"sourceRoot":""}